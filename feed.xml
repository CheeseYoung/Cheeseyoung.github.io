<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://cheeseyoung.github.io//jekyll-theme-yat/feed.xml" rel="self" type="application/atom+xml" /><link href="https://cheeseyoung.github.io//jekyll-theme-yat/" rel="alternate" type="text/html" /><updated>2025-08-14T08:19:24+00:00</updated><id>https://cheeseyoung.github.io//jekyll-theme-yat/feed.xml</id><title type="html">매일 기록하는 코딩 공부 일지</title><subtitle>매일 기록하고자 하지만 힘과 시간이 남을 경우만 가능한 공부 일기</subtitle><author><name>YoungEun Jo</name></author><entry><title type="html">[객체지향 분석과 설계] 업무분석 개요와 요구사항 정의</title><link href="https://cheeseyoung.github.io//jekyll-theme-yat/o/2024/07/25/ooad01.html" rel="alternate" type="text/html" title="[객체지향 분석과 설계] 업무분석 개요와 요구사항 정의" /><published>2024-07-25T00:00:00+00:00</published><updated>2024-07-25T00:00:00+00:00</updated><id>https://cheeseyoung.github.io//jekyll-theme-yat/o/2024/07/25/ooad01</id><content type="html" xml:base="https://cheeseyoung.github.io//jekyll-theme-yat/o/2024/07/25/ooad01.html"><![CDATA[<h2 id="sw-공학-현황">SW 공학 현황</h2>
<h3 id="sw에-대한-요구사항">S/W에 대한 요구사항</h3>
<ul>
  <li>고품질 (High Quality)</li>
  <li>짧은 납기 (Quick Delivery)</li>
  <li>낮은 개발과 유지보수 비용 (Low Development and Maintenance cost)
    <blockquote>
      <p>근데 요구사항은 불분명하고, 끊임없이 변하고 너무 많음</p>
      <h3 id="프로젝트-재작업-비용">프로젝트 재작업 비용</h3>
    </blockquote>
  </li>
  <li>프로젝트 비용 중 요구사항 재작업 비율은 28~42.5%</li>
  <li>재작업 비용 중 요구사항 결함 비율은 70~85%
    <h3 id="성공적인-sw-개발을-위해서는">성공적인 SW 개발을 위해서는</h3>
  </li>
  <li>사용할 것을 <code class="language-plaintext highlighter-rouge">우선순위</code>에 따라 <code class="language-plaintext highlighter-rouge">중복없이</code>, <code class="language-plaintext highlighter-rouge">빠짐없이</code>, <code class="language-plaintext highlighter-rouge">제대로</code>, <code class="language-plaintext highlighter-rouge">빨리</code>, <code class="language-plaintext highlighter-rouge">싸게</code></li>
</ul>

<h2 id="요구공학">요구공학</h2>
<ul>
  <li>요구사항 수집 : 수집과 협업</li>
  <li>요구사항 분석 : 요구사항 분석과 설계 정의</li>
  <li>요구사항 명세 : 요구사항 분석과 설계 정의(문서화)</li>
  <li>요구사항 확인 : 솔루션 평가</li>
  <li>요구사항 관리 : 요구사항 생명주기 관리</li>
</ul>

<h2 id="업무-배경도-작성-실습">업무 배경도 작성 실습</h2>
<p><b>온라인 서점의 업무 배경도(context diagram)를 작성</b><br /></p>
<ul>
  <li>상세 내용
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>abc 온라인 서점은 고객이 책을 인터넷으로 조회하고, 구매하고, 서평을 작성하고, 배달 현황을 조회하는 시스템.
abc사는 책 catalog와 함께, 판매 가격 및 재고를 관리한다.
고객은 책 조회 후 바로 구매할 수도 있고, 장바구니에 등록하여 필요 시점에 조회하여 주문할 수 있으며,
결제 방법은 신용카드와 인터넷 뱅킹 2가지 방법이 있다.
abc가 보유하지 않은 책은 amazon wheb servies를 이요하여 주문할 수 있다.
주문 후 배송 정보는 온라인으로 조회할 수 있다.
</code></pre></div>    </div>
  </li>
  <li>내가 작성한 것과 모범답안
<img width="45%" alt="내가작성한거" src="https://github.com/user-attachments/assets/eda551a7-5cd6-496b-ab5b-7941006398db" />
<img width="45%" alt="찐context-diagram" src="https://github.com/user-attachments/assets/be580bac-3f3f-4a85-b135-928e7911abca" /></li>
</ul>

<h2 id="usecase-diagram-작성-실습">usecase diagram 작성 실습</h2>
<p>위와 동일한 abc온라인 서점에 대한 usecase diagram 작성<br /></p>
<ul>
  <li>내가 작성한 것과 모범답안
<img width="45%" alt="내가작성한거" src="https://github.com/user-attachments/assets/ef4d4507-e5bc-465e-8da5-e4fa1fe3c020" />
<img width="45%" alt="찐usecase-diagram" src="https://github.com/user-attachments/assets/bf5a7cff-1036-4600-a6fa-738eb02b5811a" /></li>
</ul>

<h2 id="usecase-명세서-작성-실습">usecase 명세서 작성 실습</h2>
<p>위와 동일한 abc온라인 서점에서 책조회 ~ 결제 ~ 영수증 발행하는 책주문 명세서 작성 <br /></p>
<ul>
  <li>내가 작성한 것과 모범답안
<img width="45%" alt="내가작성한거" src="https://github.com/user-attachments/assets/9cc8e028-f565-4148-a666-83feabf85b27" />
<img width="45%" alt="찐usecase명세서" src="https://github.com/user-attachments/assets/c85e4e33-e556-4afd-a872-6bc755a76da6" /></li>
</ul>]]></content><author><name>Jo</name></author><category term="O" /><category term="EngineerInformationProcessing" /><category term="Study" /><summary type="html"><![CDATA[SW 공학 현황 S/W에 대한 요구사항 고품질 (High Quality) 짧은 납기 (Quick Delivery) 낮은 개발과 유지보수 비용 (Low Development and Maintenance cost) 근데 요구사항은 불분명하고, 끊임없이 변하고 너무 많음 프로젝트 재작업 비용 프로젝트 비용 중 요구사항 재작업 비율은 28~42.5% 재작업 비용 중 요구사항 결함 비율은 70~85% 성공적인 SW 개발을 위해서는 사용할 것을 우선순위에 따라 중복없이, 빠짐없이, 제대로, 빨리, 싸게]]></summary></entry><entry><title type="html">[리눅스] 5. 리눅스 IPC 메커니즘과 기본 제어</title><link href="https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/24/linux05.html" rel="alternate" type="text/html" title="[리눅스] 5. 리눅스 IPC 메커니즘과 기본 제어" /><published>2024-07-24T00:00:00+00:00</published><updated>2024-07-24T00:00:00+00:00</updated><id>https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/24/linux05</id><content type="html" xml:base="https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/24/linux05.html"><![CDATA[<h2 id="ipc-inter-process-communication">IPC (Inter Process Communication)</h2>
<p>: 프로세스 간 통신</p>
<ul>
  <li>서로 다른 프로세스가 데이터를 교환하거나 동기화할 수 있게 해주는 메커니즘</li>
  <li>IPC는 여러 가지 방법으로 구현될 수 있음
    <h3 id="파이프-pipes">파이프 (Pipes)</h3>
    <p>: 한 프로세스에서 데이터를 쓰고, 다른 프로세스에서 데이터를 읽을 수 있는 일방향 통신 채널</p>
  </li>
  <li>익명 파이프 : 같은 부모 프로세스에서 파생된 자식 프로세스 간의 통신에 사용</li>
  <li>FIFO : 파일 시스템에 이름이 부여된 파이프이며, 서로 관련이 없는 프로세스 간의 통신에 사용
    <h3 id="메시지-큐-message-queues">메시지 큐 (Message Queues)</h3>
    <p>: 프로세스 간에 구조화된 데이터를 교환할 수 있는 메커니즘</p>
  </li>
  <li>메시지는 큐에 저장되며, 다른 프로세스가 큐에서 메시지를 읽을 수 있음
    <h3 id="공유-메모리-shared-memory">공유 메모리 (Shared Memory)</h3>
    <p>: 공유 메모리는 여러 프로세스가 동시에 접근할 수 있는 메모리 영역을 제공하며, 가장 빠른 IPC 메커니즘 중 하나</p>
  </li>
</ul>

<h2 id="스레드-연습">스레드 연습</h2>
<p><img src="https://github.com/user-attachments/assets/86a24132-0c98-4c7d-9adb-760699fdd589" alt="image" /></p>
<ul>
  <li>스레드가 2개가 돌아갈 수 있도록 코드를 작성한다.</li>
  <li>main에서 <code class="language-plaintext highlighter-rouge">sleep(1)</code>을 준 이유는, 자식 스레드가 실행될 시간을 확보하려고 하는 것이다.</li>
  <li>부모 스레드인 main 함수가 종료되면 프로세스가 종료되기 때문에 자식 스레드가 실행되지 못한다.
<img src="https://github.com/user-attachments/assets/f772c5a4-3e34-4adc-a930-ca9884e92037" alt="image" /></li>
  <li>실행하면 이렇게 두 개의 스레드가 실행되는 것을 볼 수 있다.</li>
</ul>

<h2 id="스레드-종료">스레드 종료</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">pthread_exit</code> : 스레드 스스로 종료하기
    <ul>
      <li>스레드가 스스로 종료하는 가장 일반적인 방법</li>
      <li>스레드가 반환할 종료 상태를 인자로 받는다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">return</code>사용
    <ul>
      <li><code class="language-plaintext highlighter-rouge">return NULL;</code>로 종료</li>
      <li>내부적으로 <code class="language-plaintext highlighter-rouge">pthread_exit</code>과 동일하게 작동</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">pthread_cancel</code>
    <ul>
      <li>다른 스레드가 종료시키기</li>
      <li>대상 스레드에 취소 요청을 보내어 스레드를 종료</li>
    </ul>
  </li>
</ol>]]></content><author><name>Jo</name></author><category term="Linux" /><category term="EngineerInformationProcessing" /><category term="Study" /><summary type="html"><![CDATA[IPC (Inter Process Communication) : 프로세스 간 통신 서로 다른 프로세스가 데이터를 교환하거나 동기화할 수 있게 해주는 메커니즘 IPC는 여러 가지 방법으로 구현될 수 있음 파이프 (Pipes) : 한 프로세스에서 데이터를 쓰고, 다른 프로세스에서 데이터를 읽을 수 있는 일방향 통신 채널 익명 파이프 : 같은 부모 프로세스에서 파생된 자식 프로세스 간의 통신에 사용 FIFO : 파일 시스템에 이름이 부여된 파이프이며, 서로 관련이 없는 프로세스 간의 통신에 사용 메시지 큐 (Message Queues) : 프로세스 간에 구조화된 데이터를 교환할 수 있는 메커니즘 메시지는 큐에 저장되며, 다른 프로세스가 큐에서 메시지를 읽을 수 있음 공유 메모리 (Shared Memory) : 공유 메모리는 여러 프로세스가 동시에 접근할 수 있는 메모리 영역을 제공하며, 가장 빠른 IPC 메커니즘 중 하나]]></summary></entry><entry><title type="html">[리눅스] 6. 병렬 처리와 Thread 동기화</title><link href="https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/24/linux06.html" rel="alternate" type="text/html" title="[리눅스] 6. 병렬 처리와 Thread 동기화" /><published>2024-07-24T00:00:00+00:00</published><updated>2024-07-24T00:00:00+00:00</updated><id>https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/24/linux06</id><content type="html" xml:base="https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/24/linux06.html"><![CDATA[<h2 id="thread-병렬-처리">Thread 병렬 처리</h2>
<h3 id="병렬성parallelism">병렬성(Parallelism)</h3>
<ul>
  <li>동시에 진행되는 동시적인 작업</li>
  <li>병렬성은 작업들이 동일한 방향으로 교차됨 없이 독립적으로 진행되는 것을 의미
    <h3 id="병렬성-vs-동시성concurrency">병렬성 vs 동시성(Concurrency)</h3>
  </li>
  <li>병렬성은 정확한 의미로는 오직 다중 프로세서 시스템에서만 가능</li>
  <li>동시성은 단일 프로세서와 다중 프로세서 시스템 모두에서 가능</li>
  <li>동시성은 본질적으로 병렬성을 흉내낸 것으로, 단일 프로세서에서 동작이 가능</li>
  <li>병렬성은 프로그램이 동시에 두 가지 계산을 하도록 요구하지만,</li>
  <li>동시성은 단지 두 가지 일이 동시에 발생하는 것 처럼 보이게끔 해 줌
    <h3 id="thread-병렬-처리-1">Thread 병렬 처리</h3>
  </li>
  <li>스레드 안전 (thread-safe)
    <ul>
      <li>멀티 스레드 환경에서 다수의 스레드가 동시에 함수를 호출하더라도 공유되는 데이터를 안전하게 보호하는 코드</li>
      <li>여러 스레드가 공유 데이터에 대한 data-race 현상이 발생하지 않도록 하거나</li>
      <li>여러 스레드가 전역 변수로 사용되는 데이터에 동시 접근을 방지하기 위해서</li>
    </ul>
  </li>
  <li>재진입 (reentrant)
    <ul>
      <li>싱글 스레드 환경에서 호출한 함수의 실행이 종료되기 이전에 외부 인터럽트에 의해 해당 함수로의 진입이 가능</li>
      <li>re-entrancy를 보장하는 방법은 지역변수만을 사용하는 것, 즉 스레드 내에서는 static이나 전역 변수를 사용하지 않고, 정적 데이터에 대한 포인터를 반환하지 않는다.
        <h3 id="멀티-스레드를-사용한-병렬-처리-프로그래밍-모델의-장점">멀티 스레드를 사용한 병렬 처리 프로그래밍 모델의 장점</h3>
      </li>
    </ul>
  </li>
  <li>성능 향상
    <ul>
      <li>여러 작업을 동시에 처리할 수 있어 cpu 활용률을 극대화하고 성능을 향상</li>
      <li>다중 코어 cpu 환경에서 각 스레드는 별도의 코어에서 실행되어 병렬처리를 수행</li>
    </ul>
  </li>
  <li>응답성 개선
    <ul>
      <li>응답성이 중요한 애플리케이션에서 매우 유용</li>
      <li>예를 들면 사용자 입력을 처리하는 동안 백그라운드에서 긴 작업을 수행하는 스레드가 실행</li>
    </ul>
  </li>
  <li>리소스 공유
    <ul>
      <li>스레드는 동일한 프로세스 내에서 실행되므로, 동일한 메모리 공간과 리소스를 공유</li>
      <li>프로세스 간 통신보다 빠르고 효율적</li>
      <li>스레드 간의 데이터 교환이 쉽고 빠르며, 작업을 효과적으로 협력할 수 있음</li>
    </ul>
  </li>
  <li>병목 현상 감소
    <ul>
      <li>멀티 스레드는 I/O작업이나 네트워크 통신과 같은 블로킹 작업에서 발생하는 병목 현상을 줄일 수 있음</li>
      <li>한 스레드가 블로킹 상태에 있을 때 다른 스레드가 계속 실행될 수 있음</li>
    </ul>
  </li>
</ul>]]></content><author><name>Jo</name></author><category term="Linux" /><category term="EngineerInformationProcessing" /><category term="Study" /><summary type="html"><![CDATA[Thread 병렬 처리 병렬성(Parallelism) 동시에 진행되는 동시적인 작업 병렬성은 작업들이 동일한 방향으로 교차됨 없이 독립적으로 진행되는 것을 의미 병렬성 vs 동시성(Concurrency) 병렬성은 정확한 의미로는 오직 다중 프로세서 시스템에서만 가능 동시성은 단일 프로세서와 다중 프로세서 시스템 모두에서 가능 동시성은 본질적으로 병렬성을 흉내낸 것으로, 단일 프로세서에서 동작이 가능 병렬성은 프로그램이 동시에 두 가지 계산을 하도록 요구하지만, 동시성은 단지 두 가지 일이 동시에 발생하는 것 처럼 보이게끔 해 줌 Thread 병렬 처리 스레드 안전 (thread-safe) 멀티 스레드 환경에서 다수의 스레드가 동시에 함수를 호출하더라도 공유되는 데이터를 안전하게 보호하는 코드 여러 스레드가 공유 데이터에 대한 data-race 현상이 발생하지 않도록 하거나 여러 스레드가 전역 변수로 사용되는 데이터에 동시 접근을 방지하기 위해서 재진입 (reentrant) 싱글 스레드 환경에서 호출한 함수의 실행이 종료되기 이전에 외부 인터럽트에 의해 해당 함수로의 진입이 가능 re-entrancy를 보장하는 방법은 지역변수만을 사용하는 것, 즉 스레드 내에서는 static이나 전역 변수를 사용하지 않고, 정적 데이터에 대한 포인터를 반환하지 않는다. 멀티 스레드를 사용한 병렬 처리 프로그래밍 모델의 장점 성능 향상 여러 작업을 동시에 처리할 수 있어 cpu 활용률을 극대화하고 성능을 향상 다중 코어 cpu 환경에서 각 스레드는 별도의 코어에서 실행되어 병렬처리를 수행 응답성 개선 응답성이 중요한 애플리케이션에서 매우 유용 예를 들면 사용자 입력을 처리하는 동안 백그라운드에서 긴 작업을 수행하는 스레드가 실행 리소스 공유 스레드는 동일한 프로세스 내에서 실행되므로, 동일한 메모리 공간과 리소스를 공유 프로세스 간 통신보다 빠르고 효율적 스레드 간의 데이터 교환이 쉽고 빠르며, 작업을 효과적으로 협력할 수 있음 병목 현상 감소 멀티 스레드는 I/O작업이나 네트워크 통신과 같은 블로킹 작업에서 발생하는 병목 현상을 줄일 수 있음 한 스레드가 블로킹 상태에 있을 때 다른 스레드가 계속 실행될 수 있음]]></summary></entry><entry><title type="html">[리눅스] 3. 리눅스 시그널 및 동작 제어</title><link href="https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/23/linux03.html" rel="alternate" type="text/html" title="[리눅스] 3. 리눅스 시그널 및 동작 제어" /><published>2024-07-23T00:00:00+00:00</published><updated>2024-07-23T00:00:00+00:00</updated><id>https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/23/linux03</id><content type="html" xml:base="https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/23/linux03.html"><![CDATA[<h2 id="시그널이란">시그널이란?</h2>
<ul>
  <li>비동기 이벤트를 처리하기 위한 메커니즘을 제공하는 소프트웨어 인터럽트</li>
  <li>프로세스간 동신(IPC)의 기본 형태의 하나</li>
  <li>커널에서 프로세스로, 프로세스에서 다른 프로세스로, 또는 프로세스에서 자체로 전송할 수 있음</li>
  <li>시그널이 전달될 수 있을 때 커널이 적절한 방법으로 처리
    <ul>
      <li>시그널 무시 (Ignore the signal)</li>
      <li>시그널 수신 및 처리 (Catch and handle the signal)</li>
      <li>기본 동작 수행 - 프로세스 종료
<img src="https://github.com/user-attachments/assets/64b01039-b012-4a65-910b-a430e4cba051" alt="image" /></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">kill -l</code> 명령어로 시그널 목록을 볼 수 있다.</li>
  <li>1~31번 시그널은 Standard signal</li>
  <li>32, 33번은 미리 예약되어있는 시그널로 유저나 어플리케이션이 사용할 수 없다.</li>
  <li>34~64번 시그널은 Real-Time signal</li>
</ul>

<h3 id="자주-사용하는-시그널">자주 사용하는 시그널</h3>
<p>//정리</p>

<h2 id="시그널-연습">시그널 연습</h2>
<p><img src="https://github.com/user-attachments/assets/5bb2569e-287e-4177-bf96-387d7b4e8327" alt="image" /></p>
<ul>
  <li>무한 루프를 도는 코드를 작성해보자.</li>
  <li>이 파일을 실행하면 <code class="language-plaintext highlighter-rouge">running ---- 숫자</code>가 2초에 한번씩 출력될 것이다.
<img src="https://github.com/user-attachments/assets/2ff58da2-5787-4815-8942-7650cf083ff2" alt="image" /></li>
  <li>실행해보면, 예상처럼 이렇게 출력이 된다.(끝나지않음)</li>
  <li>이 코드를 종료시키려면 <code class="language-plaintext highlighter-rouge">컨트롤 C</code>를 하면 종료된다.
<img src="https://github.com/user-attachments/assets/0fa9ee3d-e3fe-4c67-af6d-8a927fb2ddd6" alt="image" /></li>
  <li>컨트롤c를 입력하니 종료된다.
<img src="https://github.com/user-attachments/assets/933183eb-278e-49d7-93d7-6e47cc3e7e3e" alt="image" /></li>
  <li><code class="language-plaintext highlighter-rouge">stty -a</code>로 터미널의 제어 문자를 확인할 수 있다.
<img src="https://github.com/user-attachments/assets/8c716222-ad24-4e7b-bc5c-491af547d74a" alt="image" /></li>
  <li>여기서 <code class="language-plaintext highlighter-rouge">signal()</code>로 시그널을 제어해보자.</li>
  <li>컨트롤 C가 작동하지 않게 설정했다.
<img src="https://github.com/user-attachments/assets/643508c5-9027-465e-a110-d9483e09a260" alt="image" /></li>
  <li>실행을 하고, 컨트롤 C를 해도 계속 코드가 돌아가는 것을 볼 수 있다.
<img src="https://github.com/user-attachments/assets/7c9c606b-d174-461d-9a8c-d696c73bce42" alt="image" /></li>
  <li>위에서 확인한 시그널 번호를 토대로 이런식으로 시그널을 제어할 수 있다.</li>
</ul>

<p><em>추가</em> <br /></p>
<ul>
  <li>코드를 완전히 종료하는게 아니라 잠시 멈출때는 컨트롤z로 할 수 있다.</li>
  <li>컨트롤 제트를 하면 잠시 멈추고, 다시 마저 실행시키려면 <code class="language-plaintext highlighter-rouge">$ fd</code>를 하면 된다.</li>
  <li>만약 컨트롤 제트까지 막아놓은 코드라면, 방법은 죽이는 것 밖에 없다.</li>
  <li><code class="language-plaintext highlighter-rouge">$ kill -9</code>를 통해 강종하자.</li>
</ul>]]></content><author><name>Jo</name></author><category term="Linux" /><category term="EngineerInformationProcessing" /><category term="Study" /><summary type="html"><![CDATA[시그널이란? 비동기 이벤트를 처리하기 위한 메커니즘을 제공하는 소프트웨어 인터럽트 프로세스간 동신(IPC)의 기본 형태의 하나 커널에서 프로세스로, 프로세스에서 다른 프로세스로, 또는 프로세스에서 자체로 전송할 수 있음 시그널이 전달될 수 있을 때 커널이 적절한 방법으로 처리 시그널 무시 (Ignore the signal) 시그널 수신 및 처리 (Catch and handle the signal) 기본 동작 수행 - 프로세스 종료 kill -l 명령어로 시그널 목록을 볼 수 있다. 1~31번 시그널은 Standard signal 32, 33번은 미리 예약되어있는 시그널로 유저나 어플리케이션이 사용할 수 없다. 34~64번 시그널은 Real-Time signal]]></summary></entry><entry><title type="html">[리눅스] 4. 리눅스 프로세스 동작과 제어</title><link href="https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/23/linux04.html" rel="alternate" type="text/html" title="[리눅스] 4. 리눅스 프로세스 동작과 제어" /><published>2024-07-23T00:00:00+00:00</published><updated>2024-07-23T00:00:00+00:00</updated><id>https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/23/linux04</id><content type="html" xml:base="https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/23/linux04.html"><![CDATA[<h2 id="프로그램-프로세스-스레드">프로그램, 프로세스, 스레드</h2>
<h3 id="프로그램program">프로그램(Program)</h3>
<ul>
  <li>소스 코드가 컴파일 된 실행 코드, binary로 디스크와 같은 저장 매체에 휴면 상태로 저장되어있는 것</li>
  <li>규모가 크고 중요한 프로그램을 어플리케이션이라고도 함</li>
  <li>/bin/ls, /usr/bin/cp
    <h3 id="프로세스process">프로세스(Process)</h3>
  </li>
  <li>실행중인 프로그램은 물론 프로그램을 실행하는데 필요한 모든 환경, 즉 context를 통틀어 프로세스라 함</li>
  <li>프로세스에는 메모리에 로드된 binary 이미지가 포함되지만 가상 메모리 인스턴스, 커널 리소스(열린 파일), 보안 컨텍스트(사용자), 하나 이상의 쓰레드가 포함</li>
  <li>프로세스에는 커널에서 유일한 식별자 <b>pid</b>가 할당됨 (최대값 : 32768)</li>
  <li>리눅스의 모든 프로세스는 부모와 자식 관계를 이루면서 실행됨 (fork-exec)
    <h3 id="스레드thread">스레드(Thread)</h3>
  </li>
  <li>프로세스 내부의 활동 단위</li>
  <li>각 스레드에는 스택, 레지스터와 같은 프로세서 상태 및 명령 포인터를 포함하는 자체 가상화 프로세서가 있음</li>
  <li>단일 스레드 프로세스에서 프로세스는 스레드. 즉 가상화된 메모리 인스턴스와 가상화 된 프로세서가 하나씩 있음</li>
</ul>

<h2 id="fork">fork()</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">fork()</code> 함수를 수행하면 리눅스 커널에서는 이 함수를 호출한 프로세스와 거의 동일한 이미지로 동작하는 새로운 프로세스를 생성한다.</li>
  <li>함수를 호출한 쪽이 부모, 새로 생성된 쪽이 자식 프로세스</li>
  <li>자식 프로세스는 <code class="language-plaintext highlighter-rouge">execl()</code>을 호출하여 <code class="language-plaintext highlighter-rouge">/bin/ls</code> 프로그램을 실행한다.</li>
  <li><code class="language-plaintext highlighter-rouge">execl()</code>은 성공시 호출 이후의 코드를 실행하지 않으며, 실패시 <code class="language-plaintext highlighter-rouge">perror()</code>를 호출하여 에러메시지를 출력한다.</li>
</ul>

<h2 id="fork-연습">fork 연습</h2>

<p><img src="https://github.com/user-attachments/assets/d00964cc-f2cc-4336-99f9-12b76046aa9f" alt="image" /></p>
<ul>
  <li>내 pid를 찍고, <code class="language-plaintext highlighter-rouge">fork()</code> 한 다음에, 다시 pid를 찍어보자.
<img src="https://github.com/user-attachments/assets/29bd1bc4-7245-4075-8eed-4332a5ed617a" alt="image" /></li>
  <li>분명 2번 print했는데 3번이나 출력됐다.</li>
  <li>fork()를 호출하면 현재 프로세스가 두 개의 프로세스로 복제된다.</li>
  <li>fork() 호출 이후의 코드는 부모 프로세스와 자식 프로세스 모두에서 실행된다.
<img src="https://github.com/user-attachments/assets/5ad607fc-d63b-456a-8b5c-a1e16ff549dc" alt="image" /></li>
  <li>그래서 이렇게 코드를 수정하고 다시 실행해보자.
<img src="https://github.com/user-attachments/assets/687fe54c-95e3-4f03-b88d-8995d070e642" alt="image" /></li>
  <li>그러면 원래(부모)프로세스는 1369번, 자식 프로세스는 1370번이고, 자식의 자식은 0인걸 알 수 있다.
<img src="https://github.com/user-attachments/assets/f37e31bb-53b6-497f-b71e-05b79cff101d" alt="image" /></li>
  <li>자식과 부모 프로세스를 나눠서 코드를 짜보자.
<img src="https://github.com/user-attachments/assets/f559e3a5-e4fe-41a2-9617-5b1faba429d2" alt="image" /></li>
  <li>이렇게 실행되는 것을 볼 수 있다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/e2e5ad65-1e36-4d5e-80ad-bdcddb7b469f" alt="image" /></p>
<ul>
  <li>만약 할 일이 끝난 자식 프로세스를 exit()처리해주면 어떻게 될까?
<img src="https://github.com/user-attachments/assets/88d142a5-e505-4367-ba3f-563b5d1ce3ac" alt="image" /></li>
  <li>exit()되지 않고, 대기 상태로 머물게 된다.</li>
  <li>이는 <code class="language-plaintext highlighter-rouge">자식이 구천을 떠돈다..</code>며 강사님이 말씀하심 ㅎ (왜 이런 농담이 웃기지)</li>
  <li>부모 프로세스가 자식프로세스를 정리해줘야한다.</li>
  <li>부모가 먼저 죽으면,, 양부모가 생긴다.</li>
  <li>자식들 중에 하나가 죽으면 나머지 자식들도 죽게 설정할 수 있다.</li>
  <li>자식들은 분가할 수 있다.
<img src="https://github.com/user-attachments/assets/73fed2c0-ca79-4bea-a803-a023e6b14e8c" alt="image" /></li>
  <li>헷갈려서 물어보니, 부모프로세스가 죽으면 조부모프로세스(내맘대로)가 양부모가 되는게 아니고</li>
  <li>PID 1 이 양부모가 된다고 한다.</li>
  <li>고아 프로세스가 되면 다 pid1이 양부모.. PID 1은 고아원</li>
</ul>

<h2 id="데몬-프로세스-daemon">데몬 프로세스 (Daemon)</h2>
<ul>
  <li>주로 시스템 시작시 생성되었다가 시스템 종료시까지 실행되는 프로세스
    <ul>
      <li>cron, sshd, httpd, inetd 등</li>
    </ul>
  </li>
  <li>백그라운드에서 실행되며 사용자 인터페이스 없이 시스템에서 특정 작업을 수행하는 프로세스</li>
  <li>시스템 부팅시 시작되거나, 특정 이벤트에 의해 생성된다.</li>
  <li>서브 프로세스, 로그 관리, 백업 작업 등과 같은 반복적이고 지속적인
    <ul>
      <li>Daemon 프로세스는 root 계정으로 실행하거나 개별 사용자 계정으로도 실행 가능</li>
      <li>프로세스 시작과 종료는 systemd 유틸리티를 사용하거나 시그널을 사용하는 것이 일반적</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">/</code> 디렉토리 하위에 작업 디렉토리를 설정
    <ul>
      <li>mount 된 파일시스템에서 실행되는 경우 필요시 해당 파일 시스템을 unmount 할 수 없다.</li>
    </ul>
  </li>
  <li>SysV 형식의 데몬과 새로운 형식의 데몬의 2가지가 있다.
    <ul>
      <li>하위 호환성을 위해서 SysV 데몬이 필요하지만 그렇지 않을 경우에는 새로운 형식의 데몬 권장</li>
    </ul>
  </li>
</ul>

<p>###</p>]]></content><author><name>Jo</name></author><category term="Linux" /><category term="EngineerInformationProcessing" /><category term="Study" /><summary type="html"><![CDATA[프로그램, 프로세스, 스레드 프로그램(Program) 소스 코드가 컴파일 된 실행 코드, binary로 디스크와 같은 저장 매체에 휴면 상태로 저장되어있는 것 규모가 크고 중요한 프로그램을 어플리케이션이라고도 함 /bin/ls, /usr/bin/cp 프로세스(Process) 실행중인 프로그램은 물론 프로그램을 실행하는데 필요한 모든 환경, 즉 context를 통틀어 프로세스라 함 프로세스에는 메모리에 로드된 binary 이미지가 포함되지만 가상 메모리 인스턴스, 커널 리소스(열린 파일), 보안 컨텍스트(사용자), 하나 이상의 쓰레드가 포함 프로세스에는 커널에서 유일한 식별자 pid가 할당됨 (최대값 : 32768) 리눅스의 모든 프로세스는 부모와 자식 관계를 이루면서 실행됨 (fork-exec) 스레드(Thread) 프로세스 내부의 활동 단위 각 스레드에는 스택, 레지스터와 같은 프로세서 상태 및 명령 포인터를 포함하는 자체 가상화 프로세서가 있음 단일 스레드 프로세스에서 프로세스는 스레드. 즉 가상화된 메모리 인스턴스와 가상화 된 프로세서가 하나씩 있음]]></summary></entry><entry><title type="html">[리눅스] 1. 리눅스 실습 환경 설정</title><link href="https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/22/linux01.html" rel="alternate" type="text/html" title="[리눅스] 1. 리눅스 실습 환경 설정" /><published>2024-07-22T00:00:00+00:00</published><updated>2024-07-22T00:00:00+00:00</updated><id>https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/22/linux01</id><content type="html" xml:base="https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/22/linux01.html"><![CDATA[<p><img src="https://github.com/user-attachments/assets/cbdc393a-8fc1-4719-b5c6-8ee3b4453099" alt="image" /></p>

<h2 id="활용-툴">활용 툴</h2>
<ul>
  <li>리눅스 OS (Ubuntu 24.04)</li>
  <li>Virtual Box를 이용해 가상화</li>
  <li>putty를 이용해 원격 접속</li>
</ul>

<h2 id="실습-환경-설정">실습 환경 설정</h2>

<ul>
  <li>VirtualBox : 가상화 솔루션
<img src="https://github.com/user-attachments/assets/680bfddc-03b3-4b8c-a68f-3f2728c91171" alt="image" /></li>
  <li>머신 &gt; 추가 &gt; 만들어놓은 vbox파일 선택
<img src="https://github.com/user-attachments/assets/8fa4fee1-4e14-4c13-9123-5c439586d2a2" alt="image" /></li>
  <li>추가 완료.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/0ae37c3d-4eef-41b7-bdd4-050d6a4a7a32" alt="image" />
<img src="https://github.com/user-attachments/assets/7c56a977-68e3-499b-8c8b-4db44a703053" alt="image" /></p>
<ul>
  <li>네트워크 어댑터는 2개를 사용한다.</li>
  <li>VM에 생성하는 NAT로는 리눅스 환경을 볼 수 없어서 Host-only도 같이 사용한다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/56c764ad-f0e2-4603-933d-0848a2f5d24e" alt="image" /></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ifcongig</code>를 하면 정보가 나온다.</li>
  <li>여기서 노란색 줄 처리한 게 host-only의 ip주소</li>
  <li>이 ip주소를 사용해서 putty에서 접속하면 된다.
<img src="https://github.com/user-attachments/assets/d60f603a-de13-4124-89e6-a6fc3b2d0299" alt="image" /></li>
  <li>푸티를 켜서 아까 본 ip주소를 입력하면 접속 할 수 있다.</li>
  <li>다음에도 사용할 주소라면, 구분할 수 있는 이름을 입력하고 save를 누르면 정보가 저장된다.</li>
  <li>저장해두면, 그냥 클릭해서 로드하면 된다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/e5d70134-ea7f-417a-ba77-d13ada7b8161" alt="image" /></p>
<ul>
  <li>open하고 id pwd를 입력하면 이렇게 접속된 걸 볼 수 있다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/6e50a4f2-e9ea-4237-adda-89c3869cdf86" alt="image" /></p>
<ul>
  <li>putty에 입력한 ip주소를 윈도우파일시스템에서<code class="language-plaintext highlighter-rouge">\\ip주소</code>로 볼 수 있다.(Samba)
<img src="https://github.com/user-attachments/assets/87b39e0e-9784-4c8c-979f-ad33f63c8bf8" alt="image" /></li>
  <li>이렇게 리눅스 파일을 볼 수 있다.
<img src="https://github.com/user-attachments/assets/778a499d-4d5d-43f2-8f04-f679c94e4246" alt="image" /></li>
  <li>putty로 ls 확인하면 아까랑 같은 목록을 볼 수 있다.</li>
</ul>]]></content><author><name>Jo</name></author><category term="Linux" /><category term="EngineerInformationProcessing" /><category term="Study" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[리눅스] 2. 리눅스 시스템 프로그래밍</title><link href="https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/22/linux02.html" rel="alternate" type="text/html" title="[리눅스] 2. 리눅스 시스템 프로그래밍" /><published>2024-07-22T00:00:00+00:00</published><updated>2024-07-22T00:00:00+00:00</updated><id>https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/22/linux02</id><content type="html" xml:base="https://cheeseyoung.github.io//jekyll-theme-yat/linux/2024/07/22/linux02.html"><![CDATA[<h2 id="리눅스-운영체제-구조">리눅스 운영체제 구조</h2>
<p><img src="https://github.com/user-attachments/assets/ca2cbcfd-a865-406f-8045-41b1b7aba1a4" alt="image" /></p>
<ul>
  <li>
    <dl>
      <dt>Kernel</dt>
      <dd>하드웨어를 제어하기 위해서는 커널을 무조건 거쳐야한다.
다만 모든 사용자가 커널을 조작하려고 하면 커널이 복잡해지기 때문에, 룰이 정해져있다.
그 룰이 <em>시스템콜</em></dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt>System Calls</dt>
      <dd>커널에 접근하려면 반드시 시스템콜을 거쳐야한다.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt>Libraries</dt>
      <dd>시스템 콜을 사용하기 쉽게 만들어놓은 것</dd>
    </dl>
  </li>
  <li>Applications</li>
</ul>

<h3 id="커널">커널</h3>
<ul>
  <li>운영체제의 가장 핵심적인 역할</li>
  <li>시스템의 다른 모든 부분을 위한 기본적인 서비스 제공</li>
  <li>하드웨어를 관리하고 시스템 자원을 분배하는 소프트웨어</li>
  <li>커널이 관리하는 자원 (물리적 자원 -&gt; 추상적 자원)
    <ul>
      <li>물리적 자원 : CPU, 메모리, 디스크, 터미널, 네트워크 등 시스템을 구성하고 있는 요소들과 주변 장치 등</li>
      <li>추상적 자원
        <ul>
          <li>태스크, 쓰레드 : CPU 추상화</li>
          <li>세그먼트, 페이지 : 메모리 추상화</li>
          <li>파일, inode : 디스크 추상화</li>
          <li>프로토콜, 패킷 : 네트워크 추상화</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="시스템-콜">시스템 콜</h3>
<ul>
  <li>사용자 공간의 어플리케이션이 운영 체제에게 필요한 서비스 또는 자원을 요청하기 위해 커널로 진입하는 함수</li>
  <li>또는 사용자 모드에서 사용할 수 있도록 밖으로 노출되어있는 커널 함수로 커널 API라고도 할 수 있음</li>
  <li>아키텍처마다 커널에 서비스 요청을 하는 software interrupt가 다르고 가용한 시스템 콜이 다</li>
  <li>시스템 콜을 일으키는 루틴을 wrapper routine이라 하고 glibc에 위치하고 있음
<img src="https://github.com/user-attachments/assets/ade29260-22e7-4d5f-8197-f768e2f34dbd" alt="image" /></li>
  <li>man read 를 사용하면 볼 수 있으며, 체크한 부분이 명령어이다.</li>
  <li>체크한 부분 위의 <code class="language-plaintext highlighter-rouge">#include &lt;&gt;</code>가 이 파일이 어떤 파일인지에 대해서 알려주는 부분</li>
</ul>

<h3 id="c-라이브러리">C 라이브러리</h3>
<ul>
  <li>C 라이브러리는 고수준 라이브러리로 둘러쌓이고 핵심 서비스를 제공하며 시스템 호출을 용이하게 함</li>
  <li>C 라이브러리는 GNU libc로 제공 -&gt; glibc</li>
  <li>glibc는 표준 C 라이브러를 구현하는 것 외에도 시스템 호출, 스레딩 지원 및 기본 응용 프로그램 기능을 위한 래퍼를 제공</li>
</ul>

<h2 id="파일-작성-연습하기">파일 작성 연습하기</h2>
<p><img src="https://github.com/user-attachments/assets/d1757a26-894d-46e1-9672-7b4351724724" alt="image" /></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">$ pwd</code> : 현재 내 위치</li>
  <li><code class="language-plaintext highlighter-rouge">$ git clone ~</code> 준비된 프로젝트를 git clone으로 가져온다.</li>
  <li><code class="language-plaintext highlighter-rouge">$ touch 01.c</code> 를 통해 01.c라는 이름을 가진 파일을 생성한다.</li>
  <li><code class="language-plaintext highlighter-rouge">ll</code>혹은 <code class="language-plaintext highlighter-rouge">ls</code> 명령어를 통해 파일이 생성된 것을 확인할 수 있고,</li>
  <li>파일시스템에서 생성된 파일을 확인할 수 있다.
<img src="https://github.com/user-attachments/assets/f8576a3e-7d61-40a6-b458-d770af726ede" alt="image" /></li>
  <li>노트패드++로 파일을 열어서, 내용을 작성해준다.</li>
  <li>이렇게 작성한 파일을 <code class="language-plaintext highlighter-rouge">$ gcc 01.c</code>를 통해 컴파일(?) 해준다.
<img src="https://github.com/user-attachments/assets/16ca6b76-8c4b-49c8-b57e-712ce81cdaac" alt="image" /></li>
  <li>결과를 보면 error가 표시되고 있고, #include <studio.h>를 작성하라고 되어있다.
![image](https://github.com/user-attachments/assets/58be2945-cd0d-4e5d-bb01-d438fecf96c6)</studio.h></li>
  <li>아까 작성한 파일에 <code class="language-plaintext highlighter-rouge">#include &lt;studio.h&gt;</code>를 추가해준다.
<img src="https://github.com/user-attachments/assets/08596fe2-1079-4d3b-a70c-d4a4849ba622" alt="image" /></li>
  <li>그 다음 다시 컴파일(?)하고 실행해주면 내가 작성한 코드가 실행되는 것을 볼 수 있다.</li>
</ul>

<h2 id="파일">파일</h2>
<ul>
  <li>파일은 리눅스에서 가장 근본적이고 기본적인 추상화</li>
  <li>파일에 접근하려면 먼저 파일을 열어야 한다.(읽기와 쓰기 목적으로 파일 열기 가능)
<img src="https://github.com/user-attachments/assets/49afb9b8-4d1c-4139-9672-0705ad168608" alt="image" />
Regular 파일</li>
  <li><code class="language-plaintext highlighter-rouge">-</code>로 시작하는 파일</li>
  <li>리눅스에서 일반적으로 파일이라고 하면 regular 파일을 말한다.</li>
  <li>바이트 스트림이라 부르는 선형 배열로 구성된 데이터 바이트를 담고 있음</li>
  <li>파일은 순차적으로 읽으며, 순서는 처음부터 읽을수도, 뒤부터 읽을 수도 있음
<img src="https://github.com/user-attachments/assets/128f513b-684d-4d7f-9485-657589a68c89" alt="image" /></li>
  <li>HELLO WORLD를 파일에 저장했다고 하면, 위와 같이 순차적으로 저장이 된다.</li>
  <li>여기서 처음부터 읽는 것이 아니라 W부터만 읽거나쓰고 싶다면 offset을 설정할 수 있다.</li>
</ul>

<h3 id="symbolic-link">Symbolic link</h3>
<p><img src="https://github.com/user-attachments/assets/e806b8db-23fc-4f99-b9fc-5246129304fa" alt="image" /></p>
<ul>
  <li>파일 이름에 대한 일종의 바로가기 단축 이름</li>
  <li>파일 시스템을 확장하기 위하여 허용</li>
  <li>링크된 파일의 절대 경로 정보를 담고 있</li>
</ul>

<h2 id="연습">연습</h2>

<p><code class="language-plaintext highlighter-rouge">$ man creat</code>를 하면 아래와 같이 나온다.
<img src="https://github.com/user-attachments/assets/b53cde8e-623b-474d-bad4-3796ffa59432" alt="image" /></p>
<ul>
  <li>여기서 int creat~ 를 사용하면 된다.</li>
  <li>참고로 푸티는 드래그를 하면 복사가 된다.</li>
  <li>얘를 드래그해서 아까 만든 파일(0.1c)에서 사용해보자.
<img src="https://github.com/user-attachments/assets/26d28f8d-83cd-4184-9a5b-ae0bb8b44167" alt="image" /></li>
  <li>여기서 보면 pathname이랑 mode를 파라미터로 넘겨야한다.</li>
  <li>그래서 fd를 선언해주고, creat를 사용해서 파일을 만드는 코드를 작성한다.</li>
  <li>푸티에서 <code class="language-plaintext highlighter-rouge">rm</code>를 통해 a.out파일과 file01을 삭제하고, 방금 작성한 <code class="language-plaintext highlighter-rouge">01.c</code>파일을 실행해보자.
<img src="https://github.com/user-attachments/assets/03444b0e-41b5-4b59-b157-ab688184147c" alt="image" /></li>
  <li>이렇게 fd값이 출력되는 것을 볼 수 있다.</li>
  <li>이 파일의 모드를 보면, 0666으로 설정했음에도 664로 설정되어있다.</li>
  <li>이를 방지하기 위해서 umask를 사용해보자.
<img src="https://github.com/user-attachments/assets/fced7829-16fa-454a-bef5-a2ecbdbe7ba1" alt="image" /></li>
  <li>umask를 사용하기 위해서는 <code class="language-plaintext highlighter-rouge">&lt;sys/stat.h&gt;</code>를 인클루드 해줘야한다.</li>
  <li>시스템 콜
<img src="https://github.com/user-attachments/assets/75eb0a01-9cfb-4287-beb7-d190c834728c" alt="image" /></li>
  <li>실행해보면, umask없이 생성한 file01은 모드가 664로,</li>
  <li>umask를 추가해서 생성한 file02는 모드가 666으로 설정된 것을 볼 수 있다.
<img src="https://github.com/user-attachments/assets/246df66e-3ff3-4473-a4c7-fbb13aeea639" alt="image" /></li>
  <li>이번에는 open을 써보자.</li>
  <li>open에는 flag를 파라미터로 넘길 수 있다.(open이지만 꼭 파일 열기만을 위해서 쓰지 않는다는 것)</li>
  <li>flag를 O_CREAT로 설정하고 저장
<img src="https://github.com/user-attachments/assets/a36559d3-26aa-43f4-b0dc-f23017f06e07" alt="image" /></li>
  <li>
    <p>실행해보면 file03이 생성된 것을 알 수 있다.</p>
  </li>
  <li>사용할 때는 리턴값을 꼭 확인하자.
<img src="https://github.com/user-attachments/assets/6907c4b3-8f68-40f8-8ba0-c34cef1fb6d5" alt="image" /></li>
  <li><code class="language-plaintext highlighter-rouge">man</code> 명령어로 사용한 함수에 대해서 볼 때, <code class="language-plaintext highlighter-rouge">/RETURN</code>을 입력해서 리턴값을 볼 수 있다.
<img src="https://github.com/user-attachments/assets/e3370615-ea90-42ab-a69c-f30530fe0678" alt="image" /></li>
  <li>file04를 읽기전용으로 열고, 만약 실패하면 error를 띄우고 exit하게 되는 코드를 작성
<img src="https://github.com/user-attachments/assets/40215141-fb5e-44b3-9a7b-dbe32f74c1d5" alt="image" /></li>
  <li>실행하면 내가 <code class="language-plaintext highlighter-rouge">perror()</code>에 작성한 메세지와 함께 에러 내용을 띄워준다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/8d3edf6a-a07e-4c4e-8aff-d471969562bc" alt="image" /></p>
<ul>
  <li>file03이라는 파일을 만들고, 파일의 내용을 작성하는 것도 할 수 있다.</li>
  <li>write를 통해 필요한 파라미터를 넣어주면 파일을 open하고, write한다.
<img src="https://github.com/user-attachments/assets/ef82da5d-cadd-407c-b141-d31c78cd36e4" alt="image" /></li>
  <li>실행하고 file03을 읽어보면, 01.c에서 작성한 내용이 file03에 잘 들어가있는 것을 알 수 있다.</li>
</ul>

<hr />

<h2 id="파일-열기-정리">파일 열기 정리</h2>
<ul>
  <li>파일 열기(open) 플래그(flag)
    <ul>
      <li>O_RDONLY : 읽기 전용으로 열기</li>
      <li>O_WRONLY : 쓰기 전용으로 열기</li>
      <li>O_RDWR : 읽기/쓰기 전용으로 열기</li>
      <li>O_APPEND : 파일의 끝에 자료를 추가</li>
      <li>O_CREAT : 파일의 permission이 같이 설정되어야한다. ex)0666</li>
      <li>O_EXCL : O_CREAT시 파일이 존재하는 경우, 이미 존재한다는 에러가 발생 (덮어쓰기 방지)</li>
      <li>O_TRUNC : 파일이 존재하고 일반 파일인 경우, 해당 파일의 크기를 0으로 만듬</li>
    </ul>
  </li>
</ul>

<h2 id="fdfile-descriptor">FD(File Descriptor)</h2>
<ul>
  <li>리눅스에서는 프로세스가 파일에 접근할 때 File Descriptor 라는 개념을 이용하여 접근한다.</li>
  <li>FD는 0이 아닌 정수값으로, 프로세스가 실행중에 파일을 open하면 커널은 해당 프로세스의 FD 숫자 중에 사용하지 않는 가장 작은 값을 할당한다.</li>
  <li>FD는 <code class="language-plaintext highlighter-rouge">포인터</code>의 개념</li>
  <li>FD의 특징
    <ul>
      <li>0이 아닌 정수값을 가진다.</li>
      <li>파일마다 독립적으로 존재하며, 시스템에 따라 다른 구조를 가진다.</li>
      <li>대게 보조기억장치에 저장되어 있다가 파일이 열릴때 주기억장치로 이동한다.</li>
      <li>프로세스 실행시 기본적으로 0(표준입력),1(표준출력),2(표준에러) 의 FD가 할당된다. (<unistd.h> 파일 참조)</unistd.h></li>
      <li>프로세스가 FD를 할당받게되면 3번부터 OPEN_MAX값까지 차례대로 할당받는다.</li>
      <li>OPEN_MAX값은 플랫폼에 따라 다르다</li>
    </ul>
  </li>
</ul>]]></content><author><name>Jo</name></author><category term="Linux" /><category term="EngineerInformationProcessing" /><category term="Study" /><summary type="html"><![CDATA[리눅스 운영체제 구조 Kernel 하드웨어를 제어하기 위해서는 커널을 무조건 거쳐야한다. 다만 모든 사용자가 커널을 조작하려고 하면 커널이 복잡해지기 때문에, 룰이 정해져있다. 그 룰이 시스템콜 System Calls 커널에 접근하려면 반드시 시스템콜을 거쳐야한다. Libraries 시스템 콜을 사용하기 쉽게 만들어놓은 것 Applications]]></summary></entry><entry><title type="html">2. 차트 라이브러리</title><link href="https://cheeseyoung.github.io//jekyll-theme-yat/study/2024/07/19/study11.html" rel="alternate" type="text/html" title="2. 차트 라이브러리" /><published>2024-07-19T00:00:00+00:00</published><updated>2024-07-19T00:00:00+00:00</updated><id>https://cheeseyoung.github.io//jekyll-theme-yat/study/2024/07/19/study11</id><content type="html" xml:base="https://cheeseyoung.github.io//jekyll-theme-yat/study/2024/07/19/study11.html"><![CDATA[<h2 id="차트-라이브러리">차트 라이브러리</h2>
<p><img src="https://github.com/user-attachments/assets/492740f8-2996-481e-b0d4-8646987caeaa" alt="image" /></p>

<p>화면에 데이터를 이용한 차트를 그리고 싶다면 차트 라이브러리를 이용해 그릴 수 있다.<br />
차트 라이브러리는 Chart.js, Highcharts, D3.js, Google Charts 등이 있다.<br /></p>

<h3 id="chartjs">Chart.js</h3>
<ul>
  <li>장점 : 직관적인 API 제공, 빠른 로딩 속도, 오픈 소스, 반응형 디자인</li>
  <li>단점 : 기본 제공 기능이 제한적, 고급 기능을 위한 플러그인이 적음</li>
  <li>간단하고 가벼우며, 기본적인 차트 기능을 손쉽게 구현할 수 있기 때문에 소규모 프로젝트나 간단한 시각화에 많이 사용</li>
</ul>

<h3 id="highcharts">Highcharts</h3>
<ul>
  <li>장점 : 다양한 차트 유형과 고급 기능, 다양한 인터랙티브 기능, 커스터마이징, 기업용 사용에 적합한 기술 지원과 문서 제공</li>
  <li>단점 : 상업적 사용시 라이선스 비용 발생, 파일 크기가 크고 로딩 속도가 느림, 복잡</li>
  <li>고급 인터렉티브 기능을 제</li>
</ul>

<h3 id="d3js">D3.js</h3>
<ul>
  <li>장점 : 강력한 데이터 시각화, 다양한 커스터마이징 옵션, 오픈 소스</li>
  <li>단점 : 배우기 어려움, 초기 설정과 사용이 어려움</li>
  <li>복잡한 데이터 시각화와 커스터마이징이 필요한 프로젝트에서 많이 사용</li>
</ul>

<h3 id="google-charts">Google Charts</h3>
<ul>
  <li>장점 : Google에서 제공하는 무료 서비스, 다양한 차트 유형, Google 서비스와 통합이 쉬움</li>
  <li>단점 : 고급 커스터마이징이 제한적, Google 서비스에 대한 종속성</li>
</ul>

<h2 id="cdn-사용과-로컬-사용의-차이">cdn 사용과 로컬 사용의 차이</h2>
<ul>
  <li>라이브러리를 사용하기 위해서는 스크립트를 불러와야한다.</li>
  <li>cdn방식 <code class="language-plaintext highlighter-rouge">&lt;script src = "https://code.highcharts.com/highcharts.js&gt;</code>로 불러오거나, 로컬에 저장해서 불러오거나.
    <h3 id="cdn">CDN</h3>
  </li>
  <li>장점
    <ul>
      <li>분산된 서버를 통해 콘텐츠를 제공하기 때문에, 로딩 속도가 빠름</li>
      <li>최신 버전의 라이브러리를 자동으로 제공받을 수 있어서 유지보수가 쉬워짐</li>
      <li>cdn 제공자는 보안 패치를 빠르게 적용하므로 보안성이 높음</li>
      <li>간단한 코드 한 줄로 라이브러리를 사용할 수 있어서 편리</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>인터넷 연결이 필요하고, cdn 제공자의 서버 상태에 영향을 받음</li>
      <li>라이브러리의 버전이 갑자기 바뀌면 예상치 못한 문제가 발생할 수 잇음</li>
      <li>외부 제공자의 cdn이 해킹될 경우, 영향을 받을 수 있음
        <h3 id="로컬-사용">로컬 사용</h3>
      </li>
    </ul>
  </li>
  <li>장점
    <ul>
      <li>인터넷 연결이 불안정하거나 없는 환경에서도 사용 가능</li>
      <li>파일을 로컬 서버에서 직접 제공하므로 외부 서버의 상태에 영향을 받지 않음</li>
      <li>필요한 버전으로 고정해서 사용할 수 있음</li>
      <li>버전 변화로 인한 이슈를 줄일 수 있음</li>
      <li>보안 통제를 직접할 수 있어 외부 요인에 영향을 받지 않음</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>파일을 로컬에 저장하고 관리해야 함</li>
      <li>업데이트와 유지보수를 직접해야하므로 번거로움</li>
      <li>보안 패치를 직접 적용해야 하므로 관리에 신경써야 함</li>
    </ul>
  </li>
</ul>

<h3 id="정리">정리</h3>
<p>|구분|속도및성능|유지보수|보안|편의성|
|–|–|–|–|–|
|CDN|빠름(인터넷필요)|자동 업데이트|높은 보안성|간편한 사용|
|로컬|인터넷 불필요|버전 고정 가능|전적인 보안 통제|관리 번거로움|</p>]]></content><author><name>Jo</name></author><category term="Study" /><category term="EngineerInformationProcessing" /><category term="Study" /><summary type="html"><![CDATA[차트 라이브러리]]></summary></entry><entry><title type="html">1. POI 라이브러리</title><link href="https://cheeseyoung.github.io//jekyll-theme-yat/study/2024/07/18/study10.html" rel="alternate" type="text/html" title="1. POI 라이브러리" /><published>2024-07-18T00:00:00+00:00</published><updated>2024-07-18T00:00:00+00:00</updated><id>https://cheeseyoung.github.io//jekyll-theme-yat/study/2024/07/18/study10</id><content type="html" xml:base="https://cheeseyoung.github.io//jekyll-theme-yat/study/2024/07/18/study10.html"><![CDATA[<h2 id="apache-poi">Apache POI</h2>

<p><img src="https://github.com/user-attachments/assets/bd4bc31a-b601-46dd-8f47-6f8465153dc9" alt="image" />
Apache POI는 Java 기반의 오픈 소스 라이브러리로, Microsoft Office 문서를 읽고 쓰는 기능을 제공한다.<br /></p>
<ul>
  <li>Excel, Word, PowerPoint 등의 문서 형식을 지원한다.</li>
</ul>

<h3 id="poi의-하위-컴포넌트">POI의 하위 컴포넌트</h3>
<ul>
  <li>HSSF (Horrible Spreadsheet Format): Excel 97-2003 (.xls)</li>
  <li>XSSF (XML Spreadsheet Format): Excel 2007 이상 (.xlsx)</li>
  <li>HWPF (Horrible Word Processor Format): Word 97-2003 (.doc)</li>
  <li>XWPF (XML Word Processor Format): Word 2007 이상 (.docx)</li>
  <li>HSLF (Horrible Slide Layout Format): PowerPoint 97-2003 (.ppt)</li>
  <li>XSLF (XML Slide Layout Format): PowerPoint 2007 이상 (.pptx)</li>
</ul>

<h3 id="장점">장점</h3>
<ol>
  <li>다양한 파일 형식 지원
    <ul>
      <li>xls, xlsx, doc, docx, ppt, pptx 등 다양한 파일 형식을 지원한다.</li>
    </ul>
  </li>
  <li>오픈 소스
    <ul>
      <li>poi는 오픈 소스 라이브러리라 무료로 사용 가능하며, 소스코드를 수정하고 배포할 수 있다.</li>
    </ul>
  </li>
  <li>기능
    <ul>
      <li>셀 병합, 스타일링, 수식, 이미지 삽입 등 다양한 기능을 제공한다.</li>
    </ul>
  </li>
</ol>

<h3 id="대용량-데이터-처리에서의-문제">대용량 데이터 처리에서의 문제</h3>
<ul>
  <li>Excel 2007 이상 버전인 xlsx 파일을 읽고 쓸 때 사용하는 <em>XSSFWorkbook</em>과 같은 클래스는 모든 데이터를 메모리에 유지한다. 그래서 대용량 데이터를 처리할 때 메모리 부족 문제가 발생할 수 있다.</li>
  <li>대용량 데이터 처리를 위한 <em>SXSSFWorkbook</em> 클래스가 제공된다.</li>
  <li>SXSSFWorkbook은 메모리 사용을 최적화하여 수백만 행의 데이터를 처리할 수 있다.</li>
  <li>메모리에 모든 데이터를 유지하지 않고, 디스크에 임시 파일을 생성하여 필요한 데이터만 메모리에 로드하는 스트리밍 방식으로 데이터를 처리한다.</li>
  <li>내부적으로 데이터를 임시 파일에 저장하고, 작업이 끝난 후 <code class="language-plaintext highlighter-rouge">dispose()</code> 메서드를 호출하여 임시 파일을 삭제할 수 있다.</li>
  <li>다만 위와 같이 스트리밍 방식으로 데이터를 처리하기 때문에, 이미 작성된 셀의 값을 다시 읽어올 수 없다.</li>
</ul>]]></content><author><name>Jo</name></author><category term="Study" /><category term="EngineerInformationProcessing" /><category term="Study" /><summary type="html"><![CDATA[Apache POI]]></summary></entry><entry><title type="html">[jQuery] 제이쿼리 기본 문법</title><link href="https://cheeseyoung.github.io//jekyll-theme-yat/jquery/2024/06/13/jQuery01.html" rel="alternate" type="text/html" title="[jQuery] 제이쿼리 기본 문법" /><published>2024-06-13T00:00:00+00:00</published><updated>2024-06-13T00:00:00+00:00</updated><id>https://cheeseyoung.github.io//jekyll-theme-yat/jquery/2024/06/13/jQuery01</id><content type="html" xml:base="https://cheeseyoung.github.io//jekyll-theme-yat/jquery/2024/06/13/jQuery01.html"><![CDATA[<p><br /></p>
<hr />

<h2 id="제이쿼리란">제이쿼리란</h2>
<p><img src="https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/13911e12-d5ce-4db7-a0db-c8d51e4214f4" alt="image" /></p>
<ul>
  <li>코드가 브라우저의 영향을 받아 작동하지 못하는 문제를 해결하기 위해 크로스 브라우징 기능을 가진 jQuery가 탄생</li>
  <li>자바스크립트의 라이브러리로, html 요소를 간단하고 편리하게 사용하는 기능이 내제</li>
  <li>동적인 기능 구현을 할 수 있지만 코드가 너무 길어지고 복잡해지는 자바스크립트 단점을 보완</li>
</ul>

<h3 id="장점">장점</h3>
<ol>
  <li>DOM 구조 탐색 속도
    <ul>
      <li>제이쿼리는 DOM(Document Object Model) 구조 탐색이 매우 뛰어남</li>
      <li>DOM은 문서 객체 모델로 트리 자료구조의 형태를 가지고 있음</li>
      <li>제이쿼리는 DOM구조의 순서대로 작성된 코드 사이에서 원하는 위치의 값을 가져오거나 입력할 때 편리</li>
      <li>예를 들어 자기 자신을 나타내는 $(this), 특정 요소를 모두 가져오는 $(“element name”) 등으로 상대적으로 Id나 class 값을 부여하지 않아도 위치 찾기를 쉽게 할 수 있도록 구성 되어있음</li>
    </ul>
  </li>
  <li>크로스 브라우징
    <ul>
      <li>제이쿼리는 모든 브라우저를 지원하고 있어, 코드가 깨지지 않고 동작함</li>
    </ul>
  </li>
</ol>

<h3 id="단점">단점</h3>
<ol>
  <li>속도
    <ul>
      <li>순수 자바스크립트를 이용해 구현한 코드보다 속도가 현저히 느림</li>
      <li>제이쿼리가 동작할 때 라이브러리에 걸쳐 해당 브라우저에 맞는 네이티브 자바 스크립트로 변환시켜야 하기 때문에 코드가 많을수록 속도가 느려짐</li>
      <li>그래서 요소는 class보다는 id로 가져오는 것이 좋음</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="기본문법">기본문법</h2>

<h3 id="jquery-기본-문법">jQuery 기본 문법</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">$</span><span class="p">(</span><span class="nx">선택자</span><span class="p">).</span><span class="nf">동작함수1</span><span class="p">().</span><span class="nf">동작함수2</span><span class="p">()</span>
</code></pre></div></div>
<ul>
  <li>달러($) 기호는 제이쿼리를 의미하고, 제이쿼리에 접근할 수 있게 해주는 식별자이다.</li>
  <li>선택자를 이용하여 원하는 HTML 요소를 선택하고</li>
  <li>동작 함수를 정의하여 선택된 요소에 원하는 동작을 설정한다.</li>
</ul>

<h3 id="jquery-객체">jQuery 객체</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">$</span><span class="p">()</span>
</code></pre></div></div>
<ul>
  <li>제이쿼리를 사용하기 위해서는 먼저 jQuery 객체를 생성해야한다.</li>
  <li><code class="language-plaintext highlighter-rouge">$()</code>는 <code class="language-plaintext highlighter-rouge">jQuery()</code>함수의 축약형이다.</li>
</ul>

<h2 id="css-스타일의-selector를-인수로-전달">css 스타일의 selector를 인수로 전달</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 자바스크립트로 작성</span>
<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">formInput</span><span class="dl">'</span><span class="p">)</span>

<span class="c1">// 제이쿼리로 작성</span>
<span class="nf">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">#formInput</span><span class="dl">'</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="셀렉터-이벤트-등록">셀렉터 이벤트 등록</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// 자바스크립트로 작성</span>
<span class="kd">const</span> <span class="nx">btn</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelectorAll</span><span class="p">(</span><span class="dl">'</span><span class="s1">.btn</span><span class="dl">'</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">btn</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
   <span class="nx">btn</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">});</span>
<span class="p">}</span>

<span class="c1">//제이쿼리로 작성</span>
<span class="nf">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">.btn</span><span class="dl">'</span><span class="p">).</span><span class="nf">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">});</span>
</code></pre></div></div>]]></content><author><name>Jo</name></author><category term="jQuery" /><category term="jQuery" /><summary type="html"><![CDATA[]]></summary></entry></feed>